{"version":3,"sources":["socketUsage.js","sketch.js","App.js","index.js"],"names":["socket","io","serverHost","on","console","log","emitOSC","address","value","emit","args","sketch","p","analyser","bufferLength","frameCount","timeDataArray","freqDataArray","setup","createCanvas","windowWidth","windowHeight","windowResized","resizeCanvas","myCustomRedrawAccordingToNewPropsHandler","props","Uint8Array","fftSize","btnClick","draw","undefined","getByteFrequencyData","getByteTimeDomainData","background","length","freq","threshold","max","Math","fftMax","indexOf","floor","getFreq","maxDb","textSize","fill","text","toFixed","f","d","stroke","prev","sliceWidth","x","i","y","line","App","navigator","mediaDevices","getUserMedia","audio","then","micStart","micError","stream","alert","setState","style","display","context","state","microphone","createMediaStreamSource","createAnalyser","connect","frequencyBinCount","dataArray","update","btnTxt","AudioContext","window","webkitAudioContext","timer","id","this","onClick","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.05be16b0.chunk.js","sourcesContent":["import io from 'socket.io-client'\nimport {serverHost} from './config'\n\nconst nameSpace = '/user';\nconst socket = io(serverHost+nameSpace);\nlet isSocketConnect = false;\nsocket.on('connect', () => {\n    //alert('connect!');\n    isSocketConnect = true;\n    console.log('socket connect to server');\n})\n\nexport let emitOSC = (address, value)=> {\n    socket.emit('osc', {\n        address: address,\n        args: [value]\n    });\n}\n\nexport {isSocketConnect};","import { emitOSC } from \"./socketUsage\";\n\nexport default function sketch (p) {\n    let analyser;\n    let frameCount = 0;\n    let timeDataArray = [];\n    let freqDataArray = [];\n    let btnClick;\n    let button;\n    let bufferLength;\n\n    p.setup = () => {\n        p.createCanvas(p.windowWidth, p.windowHeight);\n\n    };\n\n    p.windowResized = () =>  {\n        p.resizeCanvas(p.windowWidth, p.windowHeight);\n    }\n\n    p.myCustomRedrawAccordingToNewPropsHandler = (props) => {\n        \n        if (props.bufferLength) {\n            bufferLength = props.bufferLength;\n        }\n        if (props.analyser) {\n            if (props.analyser == null) return;\n            analyser = props.analyser;\n            timeDataArray = new Uint8Array(analyser.fftSize);\n            freqDataArray = new Uint8Array(analyser.fftSize);\n        }\n        if (props.btnClick) {\n            btnClick = props.btnClick;\n            \n            if (button) button.mousePressed(btnClick);\n        }\n    };\n\n    p.draw = function () {\n        frameCount++;\n\n        if (frameCount % 20 === 0) {\n            if (analyser !== undefined) {\n                getAnalysedData();\n                getTimeDomainData();\n            }\n        }\n        //if (dataArray.length > 0)\n        p.background(0, 0, 0);\n        if (timeDataArray.length <= 0) return;\n        // button = p.createButton('START');\n        // button.position(p.windowWidth/2, p.windowHeight/2);\n        // button.mousePressed(btnClick);\n        // button.style('background-color', p.color(255,255,255,255));\n        \n        var ths = 50;\n        var freq = getFreq(ths);\n        var maxDb = Math.max(...freqDataArray)/256.;\n        \n        p.textSize(30);\n        p.fill(100,100,100);\n        //p.text((Math.max(...timeDataArray)/256.).toFixed(2), p.windowWidth/2-100, p.windowHeight/2);\n        p.text(maxDb.toFixed(2), p.windowWidth/2, p.windowHeight/2);\n        p.text(freq, p.windowWidth/2, p.windowHeight/2+100);\n        if (maxDb > ths/255. && frameCount % 20 === 0) {\n            emitOSC('/sound', {f: freq, d: maxDb});\n        }\n        \n        p.stroke(126);\n        p.fill(0);\n        //p.fill(p.NONE);\n        let sliceWidth = p.windowWidth * 1.0 / bufferLength;\n        let x = 0;\n        let prev;\n        for(var i = 0; i < bufferLength; i++) {\n    \n            var v = timeDataArray[i] / 128.0;\n            var y = v * p.windowHeight/2;\n\n            if(i !== 0) {\n                p.line(prev[0], prev[1], x, y);\n            }\n            prev = [x, y];\n\n            x += sliceWidth;\n        }\n        p.line(prev[0], prev[1], p.windowWidth, p.windowHeight/2);\n        \n    };\n\n    function getAnalysedData() {\n        //console.log(\"getAnalysedData\");\n        analyser.getByteFrequencyData(freqDataArray);\n        //console.log(freqDataArray);\n    }\n\n    function getTimeDomainData() {\n        analyser.getByteTimeDomainData(timeDataArray);\n        //console.log(timeDataArray);\n    }\n\n    function getFreq(threshold) {\n        var fs = 44100;\n        // var N = freqDataArray.frequencyBinCount;\n        //console.log(fs, N);\n        var max = Math.max(...freqDataArray);\n        var fftMax = freqDataArray.indexOf(max) * fs / (2*bufferLength);\n        return max > threshold ? Math.floor(fftMax) : 0;\n    }\n};\n\n","import React, {Component}  from 'react';\n//import { LineChart, Line, XAxis, YAxis } from 'recharts';\n//import logo from './logo.svg';\n//import Tone from 'tone';\nimport P5Wrapper from 'react-p5-wrapper';\nimport sketch from './sketch';\nimport './App.css';\n\n\n// class App2 extends Component{\n//   //state = {};\n//   constructor() {\n//     super();\n//     this.state = {\n//       fft: new Tone.Analyser(),\n//       waveform: new Tone.Analyser('waveform', 64),\n//       mic: new Tone.UserMedia(),\n//       recordTxt: \"Record\",\n//       temp: [],\n//       fftMax: 0,\n//       waveMax: 0,\n//     };\n\n//   }\n\n//   record = () => {\n//     let {mic, recordTxt, waveform, fft} = this.state;\n//     if (recordTxt === \"Record\") {\n//       if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n//         alert(\"瀏覽器不支持 enumerateDevices() .\");\n//         return;\n//       }\n      \n//       // navigator.mediaDevices.enumerateDevices()\n//       // .then(function(devices) {\n//       //   alert('devices:');\n//       //   devices.forEach(function(device) {\n//       //     alert(device.kind + \": \" + device.label +\n//       //                 \" id = \" + device.deviceId);\n//       //   });\n//       // })\n//       // .catch(function(err) {\n//       //   alert(err.name + \": \" + err.message);\n//       // });\n      \n//       Tone.UserMedia.enumerateDevices().then(function(devices){\n//         console.log(String(devices))\n//       })\n//       mic.open().then(() => {\n//         console.log('mic open!');\n//         //alert(mic.deviceId);\n//         mic.fan(fft,waveform);\n//         this.setupPitch();\n//         this.setState({recordTxt: \"Stop\"});\n//       });\n      \n//     } else {\n//       console.log('mic close!');\n//       mic.close();\n//       this.setState({recordTxt: \"Record\"});\n//     }\n    \n    \n//   }\n\n//   setupPitch = () => {\n//     let {waveform, fft, mic} = this.state;\n\n//     // mic.toMaster();\n//     //PITCH\n//     // var pitch1 = new Tone.PitchShift().toMaster();\n//     // var pitch2 = new Tone.PitchShift().toMaster();\n//     // //Connect Mic to Pitches\n//     // mic.connect(pitch1).connect(pitch2);\n//     // //Pitch1 and Pitch together with Mic create a Major Third Chord\n//     // pitch1.pitch = 4; //one third up\n//     // pitch2.pitch = -4; //one third down\n\n//     setInterval(() => {\n//       var waveData = waveform.getValue();\n//       var max = Math.max.apply(Math, waveData);\n//       var min = Math.min.apply(Math, waveData)*-1;\n//       var r = Math.max(max, min);\n//       r *= 7;\n//       if (r < 0.1 && r !== 0) {\n//           r = 0.1;\n//       }\n\n//       var fftValue = fft.getValue();\n      \n//       //fftValue = fftValue.subarray(0, N/2 - 1);\n//       max = Math.max(...fftValue);\n//       //min = Math.min(...fftValue);\n//       //var tempMax = max > -min ? max : min;\n//       var fs = fft.context.sampleRate;\n//       var N = fft._analyser.fftSize;\n//       var fftMax = fftValue.indexOf(max) * fs / N;\n      \n//       //console.log(fft.getValue());\n//       //console.log(fft);\n//       var data = [];\n//       for (let i=0; i<fftValue.length; i++) {\n//         data.push({name: Math.floor(i * fs / N), intensity: fftValue[i]});\n//       }\n\n//       console.log(fftMax, r, this.state.mic.volume.value);\n//       this.setState((prevState) => ({\n//         temp: data, \n//         fftMax: r === 0.1 ? prevState.fftMax : Math.floor(fftMax),\n//         waveMax: (r*10).toFixed(2)\n//       }));\n\n\n//       //console.log(mic.context);\n//      //console.log(Tone.Master.volume.value);\n//     }, 200)\n//     // setTimeout(function () {\n//     //   mic.disconnect(pitch1).disconnect(pitch2);\n//     //   mic.disconnect (Tone.Master);\n//     // }, 5000);\n//   }\n\n//   render() {\n\n//     //return <MyChart />;\n//     return (\n//     <div>\n//       <button onClick={this.record}>{this.state.recordTxt}</button>\n//       {/* <MyChart data={this.state.temp}></MyChart> */}\n//       <br/><span>{this.state.fftMax} Hz</span>\n//       <br/><span>volume : {this.state.waveMax}</span>\n//     </div>\n//     );\n//   }\n\n  \n\n// }\n\n\n\nclass App extends Component {\n\n  constructor() {\n    super();\n    var AudioContext = window.AudioContext // Default\n          || window.webkitAudioContext // Safari and old versions of Chrome\n          || false; \n\n    this.state = {\n      timer: null,\n      style: {},\n      btnTxt: 'START',\n      context: AudioContext? new AudioContext() : null,\n    }\n    \n  }\n  \n\n  // componentDidMount() {\n    \n  // }\n\n  btnClick = () => {\n    navigator.mediaDevices.getUserMedia({audio: true})\n        .then(this.micStart, this.micError);\n  }\n\n  micStart = (stream) => {\n    alert('here');\n    this.setState({style:{display:'none'}});\n    let {context} = this.state;\n    var microphone = context.createMediaStreamSource(stream);\n    var analyser = context.createAnalyser();\n    microphone.connect(analyser);\n    //analyser.connect(context.destination);\n    analyser.fftSize = 2048;\n    var bufferLength = analyser.frequencyBinCount;\n    var dataArray = new Uint8Array(analyser.fftSize);\n\n    this.setState ({\n      analyser : analyser,\n      dataArray: dataArray,\n      bufferLength: bufferLength,\n      \n    });\n    this.update();\n  }\n\n  micError = () => {\n    this.setState({btnTxt:'RE-EANBLE!'});\n    console.log('error');\n  }\n\n  update = () => {\n    let {dataArray, analyser} = this.state;\n    console.log(dataArray);\n    analyser.getByteFrequencyData(dataArray);\n    //this.setState({timer:setTimeout(this.update,200)});\n  }\n\n  render() {\n\n    return (\n      <div>\n        <div id=\"wrap\" style={this.state.style}>\n          <button onClick={this.btnClick}>{this.state.btnTxt}</button>\n        </div>\n        <P5Wrapper sketch={sketch} analyser={this.state.analyser} \n           bufferLength={this.state.bufferLength}/>\n      </div>\n    );\n  }\n}\n\n// function App() {\n  \n//   return (\n//     <div/>\n//   );\n// }\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n//import * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n// serviceWorker.unregister();\n"],"sourceRoot":""}